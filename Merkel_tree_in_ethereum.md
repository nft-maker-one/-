# 以太坊中merkle tree的实现
## 什么是trie（radix tree）
radix tree是一种高效的字符串键数据结构，它广泛用于字典查找，字符串匹配等领域.它是一种树形结构，其中每个节点表示一个字符串的前缀，而每个叶子节点表示一个完整的字符串,其原理如下
1. 将每个字符串拆分为一系列字符，并将其插入到 Radix Tree 中。对于每个字符串，从根节点开始遍历 Radix Tree。对于每个节点，找到与该节点所表示的字符串前缀最长的公共前缀，然后将其余部分插入到该节点的子节点中。如果没有找到公共前缀，则创建一个新节点并将其插入到树中。
2. 当需要查找一个字符串时，从根节点开始遍历 Radix Tree。对于每个节点，找到与该节点所表示的字符串前缀最长的公共前缀，然后继续遍历与该前缀匹配的子节点。如果找到一个叶子节点，则表明该字符串存在于 Radix Tree 中；否则，该字符串不存在于 Radix Tree 中。

<div>
    <img src="https://upload.wikimedia.org/wikipedia/commons/b/be/Trie_example.svg" alt="这是一个radix tree的实例" text-align:center>
</div>

上图为一个radix tree的实例，图中ten最长的字符串前缀为te，因而将a节点插入到te节点的子节点中。ten键所对应的值为12

Radix Tree 的优点是，由于每个节点只存储其子节点所表示的字符串的公共前缀，因此可以大大减少存储空间的使用。而且，由于遍历 Radix Tree 时只需要比较每个节点所表示的字符串的公共前缀，因此可以提高字符串搜索的效率
## 以太坊中trie面临的困局
效率是radix tree的硬伤。如果你有一个很长的键，并且找不到一个很好的公共前缀，那么你需要遍历（和存储）树中的大量节点才能找到该值，尽管路径上没有其他值。

