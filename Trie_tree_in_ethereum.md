# 以太坊中tire tree的实现（此版本被放弃，完整版大家去知乎看吧，链接奉上：以太坊中tire tree的实现 - 无迹可寻的文章 - 知乎
https://zhuanlan.zhihu.com/p/627935147
## 什么是trie（radix tree）
radix tree是一种高效的字符串键数据结构，它广泛用于字典查找，字符串匹配等领域.它是一种树形结构，其中每个节点表示一个字符串的前缀，而每个叶子节点表示一个完整的字符串,其原理如下
1. 将每个字符串拆分为一系列字符，并将其插入到 Radix Tree 中。对于每个字符串，从根节点开始遍历 Radix Tree。对于每个节点，找到与该节点所表示的字符串前缀最长的公共前缀，然后将其余部分插入到该节点的子节点中。如果没有找到公共前缀，则创建一个新节点并将其插入到树中。
2. 当需要查找一个字符串时，从根节点开始遍历 Radix Tree。对于每个节点，找到与该节点所表示的字符串前缀最长的公共前缀，然后继续遍历与该前缀匹配的子节点。如果找到一个叶子节点，则表明该字符串存在于 Radix Tree 中；否则，该字符串不存在于 Radix Tree 中。

<div>
    <img src="https://upload.wikimedia.org/wikipedia/commons/b/be/Trie_example.svg" alt="这是一个radix tree的实例" text-align:center>
</div>

上图为一个radix tree的实例，图中ten最长的字符串前缀为te，因而将a节点插入到te节点的子节点中。ten键所对应的值为12

Radix Tree 的优点是，由于每个节点只存储其子节点所表示的字符串的公共前缀，因此可以大大减少存储空间的使用。而且，由于遍历 Radix Tree 时只需要比较每个节点所表示的字符串的公共前缀，因此可以提高字符串搜索的效率
## trie面临的困局
效率是radix tree的硬伤。如果你有一个很长的键，并且找不到一个很好的公共前缀，那么你需要遍历（和存储）树中的大量节点才能找到该值，尽管路径上没有其他值。就像下图所示，两个键在搜寻过程中完全没有相同的prefix，搜寻会变得非常的低效  
![低效的radix tree](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSRITXDIo3K_LOVsbhV5L2l39A0IXdX405R1A&usqp=CAU)  
## 以太坊中提出的解决方案
1.使树形数据结构具有密码学安全性。  
为了实现这一点，每个节点都被其哈希值所引用，当前实现中使用leveldb数据库进行查找。使用这种方案，根节点成为整个数据结构的加密指纹（因此称为Merkle）。其中涉及的技术术语包括哈希，leveldb数据库和Merkle树。哈希是将任意长度的消息压缩成固定长度输出的算法。leveldb是一种键值数据库，用于快速存储和检索数据。Merkle树是一种树形数据结构，在其中每个非叶子节点都是其子节点哈希的组合。
2.多样的节点类型  
以太坊中引入了包括空节点，标准叶节点，拓展节点和分支节点。空节点自然是没有存储value。标准叶节点则以[key,value]的形式存储了数据。而拓展节点也是以[key,value]的形式，但是其所存储的可能是其他节点的哈希值。具体的对应关系可以在leveldb数据库中查询。以太坊使用长度为17的列表作为分支节点，使用长度为16的十六进制字符作为键的一部分，每个分支节点都有16个子节点，对应于可能出现的16个十六进制字符。如果一个键的某一位是十六进制字符0，那么它的子节点是分支节点的第一个子节点，如果是1，那么它的子节点是分支节点的第二个子节点，以此类推，直到第16个子节点。最后一个元素保存了一个键值对，其中键以分支节点结尾，表示在Trie中以该键为结尾的值

